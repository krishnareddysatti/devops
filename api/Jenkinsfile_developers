#!/usr/bin/env groovy
@Library('JenkinsSharedLibrary') _

//node("jenkins-slave")
node {
	def projectProperties = [
		[$class: 'BuildDiscarderProperty',strategy: [$class: 'LogRotator', numToKeepStr: '3']],
		disableConcurrentBuilds(),
		parameters([
			string(name: 'GIT_BRANCH', description: 'API Branch Name', defaultValue: "feature/dev"),
			//choice(choices: ["dev", "qa"].join("\n"), description: 'Properties Environment', name: 'PROP_ENV'),
			string(name: 'DESTINATION_IP', description: 'IP of promotion env', defaultValue: "10.0.31.242"),
			booleanParam(name: 'GIT_IMAGE_PUSH', defaultValue: false,	description: 'Save image to a tar archive'),
			booleanParam(name: 'GIT_TAG', defaultValue: false, description: 'Tagging required or not')
		]),
	]
	projectProperties.add(pipelineTriggers([upstream(threshold: hudson.model.Result.SUCCESS,upstreamProjects: "common")]))
	//projectProperties.add(pipelineTriggers([cron('H 21 * * *')]))
	// Trigger build @12 and 4 PM on Week Days -- DISABLING AS THE UPSTREAM JOB WILL TRIGGER THIS BUILD
	//projectProperties.add(pipelineTriggers([cron('0 12, 16 * * 1-5')]))

	properties(projectProperties)

	Utils utils = new Utils()

	try {
		// =========== USER DEFINED VARS ===========
		def workspacePath = pwd()
		echo "workspacePath: ${workspacePath}"
		def mvnHome = tool name: "Maven_V3"
		env.PATH = "${mvnHome}/bin:${env.PATH}"
		def apiRepoUrl = 'ssh://git@innersource.accenture.com/appq/demandplannerapi.git'
		def distroRepoUrl = 'ssh://git@innersource.accenture.com/appq/distro_api.git'
		def distroDirPath = "/tmp/jenkins/distro_api"
		def applicationDir = "demandplannerapi"
		def branchName = "${GIT_BRANCH}"
		def destinationIP = "${DESTINATION_IP}"
		// =========== USER DEFINED VARS ===========


		checkout(applicationDir, branchName, apiRepoUrl, distroDirPath, distroRepoUrl,utils)
		// Since artifactName and releasedVersion fetching from POM.xml, should execute after cloning the repo.
		def artifactName = utils.getArtifact("demandplannerapi")
		def releasedVersion
		dir(applicationDir) {
			releasedVersion = sh (
					script: """ mvn help:evaluate -Dexpression=project.version -Dv=${BUILD_NUMBER} | grep -e '^[^\\[]'  """,
					returnStdout: true
					).trim()
		}
		echo "releasedVersion: ${releasedVersion}"

		// TODO: comma separated IP, put this for stmt around loadimage, another two for each environment: NOT NOW
		//DEV_ENVIRONMENT_IP, QA_ENVIRONMENT_IP 
		def devBoxes = '0.0.0.0,1.1.1.2'
		for (String i : devBoxes.split(",")) {
	 		println i
	 	}

		build(applicationDir)
		allTests(applicationDir)
		sonarScanner(applicationDir)
		allCodeQualityTests(utils)
		dockerClean(artifactName,utils)
		dockerBuild()
		saveImage(applicationDir, distroDirPath, artifactName, releasedVersion,GIT_IMAGE_PUSH, utils)
		tagBranch(applicationDir, apiRepoUrl, releasedVersion,GIT_TAG, utils)
		// PROP_ENV = dev
		deployToDev(artifactName, releasedVersion, "dev", utils)
		loadImage(distroDirPath, artifactName, releasedVersion, destinationIP,GIT_IMAGE_PUSH, utils)
		
		// PROP_ENV = qa
		//deployImageToQA(artifactName, releasedVersion, "qa", destinationIP, utils)
	}catch (error) {
		println error
		// If there was an exception thrown, the build failed
		currentBuild.result = 'FAILURE'
		throw error
	} finally {
		// Success or failure, always send notifications
		utils.sendNotification(currentBuild.result)
		/* Below CODE THROWS EXCEPTION: javax.mail.MessagingException: Could not connect to SMTP host: localhost, port: 465
		mail (
				subject: "Something is wrong with " +
				"${env.JOB_NAME} ${env.BUILD_ID}",
				to: 'r.satti@accenture.com',
				body: 'You should fix it'
			 ) */
	}
}


stage('Deploy Approval') {
   		def userInput = input(
        		id: 'deployToQA', message: 'input your option:', ok: 'ok', parameters: [string(defaultValue: '', description: '.....', name: 'TEST')]
   		)
   	echo ("Deploy Approval: " + userInput)
}

node {
	def workspacePath = pwd()
	echo "workspacePath in SECOND NODE: ${workspacePath}"
    stage('deploy to QA'){
        deployImageToQA(artifactName, releasedVersion, "qa", destinationIP, utils)
    }
}



def checkout(applicationDir, branchName, apiRepoUrl, distroDirPath, distroRepoUrl,utils) {
	stage('Git Checkout') {
		utils.sourceCodeCheckout(applicationDir, branchName, apiRepoUrl, distroDirPath, distroRepoUrl)
	}
}

def build(applicationDir) {
	stage ('Maven Build') {
		dir(applicationDir) { sh "mvn clean install -Dmaven.test.skip=true -Dv=${BUILD_NUMBER}" }
	}
}

def allTests(applicationDir) {
	stage ('Junit Test') { dir(applicationDir) {sh "mvn test -Dv=${BUILD_NUMBER}" }}
}

def sonarScanner(applicationDir) {
	stage('SonarQube Analysis') {
		dir(applicationDir) {
			withSonarQubeEnv('SonarQube_V7') { // SonarQube taskId is automatically attached to the pipeline context
				sh "mvn org.sonarsource.scanner.maven:sonar-maven-plugin:3.3.0.603:sonar -Dv=${BUILD_NUMBER}" }
		}
	}
}

def allCodeQualityTests(utils) {
	stage("SonarQube Quality Gate") { utils.processQualityGate() }
}

def dockerClean(artifactName,utils) {
	stage('Docker Clean'){ utils.removeImages(artifactName) }
}

def dockerBuild() {
	stage('Docker Build'){
		dir('demandplannerapi') {
			echo "Starting Docker Image Creation..."
			sh "mvn docker:build -Dv=${BUILD_NUMBER}"
			echo "Docker Image Creation Complted..."
		}
	}
}

def saveImage(applicationDir, distroDirPath, artifactName, releasedVersion,GIT_IMAGE_PUSH, utils) {
	stage('Save Image to Tar Archive') {
		if (GIT_IMAGE_PUSH.toBoolean()) {
			echo "Save Image to Tar Archive and pushing Tar to Git Repo"
			utils.saveImageToFS(applicationDir, distroDirPath, artifactName, releasedVersion)
			utils.saveImageToRepo(applicationDir, distroDirPath, artifactName, releasedVersion)
		} else {
			echo "Save Image to Tar Archive and Copy image to ${distroDirPath}"
			utils.saveImageToFS(applicationDir, distroDirPath, artifactName, releasedVersion)
		}
	}
}

def tagBranch(applicationDir, apiRepoUrl, releasedVersion,GIT_TAG, utils) {
	if (GIT_TAG.toBoolean()) {
		stage('Tag Branch') {
			utils.tagBranch(applicationDir, apiRepoUrl, releasedVersion)
		}
		sh "docker images"
	}
}

// Assuming jenkins box is Dev BOX and deploying application to local box
def deployToDev(artifactName, releasedVersion, PROP_ENV, utils) {
	stage('deploy to DEV'){
		utils.deployAPIToDev(artifactName, releasedVersion, PROP_ENV)
	}
}

def loadImage(distroDirPath, artifactName, releasedVersion, destinationIP,GIT_IMAGE_PUSH, utils) {
	stage('load Image'){
		utils.loadImage(distroDirPath, artifactName, releasedVersion, destinationIP)
	}
}

def deployImageToQA(artifactName, releasedVersion, PROP_ENV, destinationIP, utils) {
	
	/*
	stage('deploy to QA'){
		timeout(activity: true, time: 20, unit: 'SECONDS') {
			input message: 'Deploy to QA Env?', ok: 'Deploy, '
		}
		utils.promoteAPIToEnv(artifactName, releasedVersion, PROP_ENV, destinationIP)
	}
	*/

	stage('deploy to QA'){
		userAborted = false
		startMillis = System.currentTimeMillis()
		timeoutMillis = 10000

		try { 
			timeout(time: timeoutMillis, unit: 'MILLISECONDS') {
				input 'Do you approve?' 
			} 
		} catch (org.jenkinsci.plugins.workflow.steps.FlowInterruptedException e) {
			cause = e.causes.get(0)
			echo "Aborted by " + cause.getUser().toString()
			if (cause.getUser().toString() != 'SYSTEM') {
				startMillis = System.currentTimeMillis()
			} else {
				endMillis = System.currentTimeMillis()
				if (endMillis - startMillis >= timeoutMillis) {
				echo "Approval timed out. Continuing with deployment."
				} else {
				userAborted = true
				echo "SYSTEM aborted, but looks like timeout period didn't complete. Aborting."
				}
			}
		}

		if (userAborted) {
			currentBuild.result = 'ABORTED'
		} else {
			currentBuild.result = 'SUCCESS'
			utils.promoteAPIToEnv(artifactName, releasedVersion, PROP_ENV, destinationIP)
		}
	}

}