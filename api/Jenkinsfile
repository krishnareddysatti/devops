#!/usr/bin/env groovy
@Library('JenkinsSharedLibrary') _

node {
	properties([
		[$class: 'BuildDiscarderProperty', strategy:
			[$class: 'LogRotator', numToKeepStr: '3']],
		disableConcurrentBuilds(),
		parameters([
			choice(choices: ["master", "develop"].join("\n"), description: 'API Branch Name', name: 'API_GIT_BRANCH'),
			choice(choices: ["master", "develop"].join("\n"), description: 'Distro Branch Name', name: 'DISTRO_GIT_BRANCH'),
			choice(choices: ["dev", "qa"].join("\n"), description: 'Properties Environment', name: 'PROP_ENV'),
			//booleanParam(name: 'GIT_IMAGE_PUSH', defaultValue: false,	description: 'Image store required or not'),
			booleanParam(name: 'GIT_TAG', defaultValue: false, description: 'Tagging required or not')
		]),
		pipelineTriggers(
		[upstream(threshold: hudson.model.Result.SUCCESS,upstreamProjects: "common")
			//pollSCM('H/15 * * * *'),
			//pollSCM('* * * * *'),
			//cron('@daily')
		])
	])

	Utils utils = new Utils()

	try {
		// =========== USER DEFINED VARS ===========
		def workspacePath = pwd()
		echo "${workspacePath}"
		def mvnHome = tool name: "Maven_V3"
		env.PATH = "${mvnHome}/bin:${env.PATH}"
		def apiRepoUrl = 'ssh://git@innersource.accenture.com/appq/demandplannerapi.git'
		def distroRepoUrl = 'ssh://git@innersource.accenture.com/appq/distro_api.git'
		def devopsRepoUrl = 'ssh://git@innersource.accenture.com/appq/devops.git'
		def distroDirPath = "/tmp/jenkins/distro_api"
		def artifactName
		def releasedVersion

		// =========== USER DEFINED VARS ===========

		stage('Git Checkout') {
			deleteDir()
			echo "Checkout in progress..."
			dir('demandplannerapi') {
				git branch: '${API_GIT_BRANCH}',
				credentialsId: 'git-repo-ssh-access',
				url: "${apiRepoUrl}"
			}

			artifactName = utils.getArtifact("demandplannerapi")
			releasedVersion = utils.getReleasedVersion("demandplannerapi")

			echo "artifactName:${artifactName}"
			echo "releasedVersion:${releasedVersion}"

			dir('devops') {
				git branch: 'master',
				credentialsId: 'git-repo-ssh-access',
				url: "${devopsRepoUrl}"
			}

			// Check for directory
			if(!fileExists(distroDirPath))
			{
				sh "whoami"
				echo "${distroDirPath} doesn't exist.Continue cloning ..."


				dir(distroDirPath){
					git branch: '${DISTRO_GIT_BRANCH}',
					credentialsId: 'git-repo-ssh-access',
					url: "${distroRepoUrl}"
					/*	checkout([$class: 'GitSCM', branches: [[name: '${DISTRO_GIT_BRANCH}']], doGenerateSubmoduleConfigurations: false,
					 extensions: [[$class: 'CheckoutOption', timeout: 15], [$class: 'CloneOption', depth: 0, noTags: false, reference: '', shallow: true, timeout: 15]],
					 submoduleCfg: [], userRemoteConfigs: [[credentialsId: 'git-repo-ssh-access', url: "${distroRepoUrl}"]]]) */
				}
			}
			else {
				echo "${distroDirPath} is already exist.Continue updating ..."
				sshagent (credentials: ['git-repo-ssh-access']) {
					dir(distroDirPath) { sh "git pull origin HEAD:master" }
				}
			}
		}

		stage ('Maven Build') {
			dir('demandplannerapi') { sh "mvn clean install -Dmaven.test.skip=true" }
		}

		stage ('Junit Test') { dir('demandplannerapi') {sh "mvn test" }}

		stage('SonarQube Analysis') {
			dir('demandplannerapi') {
				withSonarQubeEnv('SonarQube_V7') { // SonarQube taskId is automatically attached to the pipeline context
					sh "mvn org.sonarsource.scanner.maven:sonar-maven-plugin:3.3.0.603:sonar" }
			}
		}

		// Configure a webhook in your SonarQube server pointing to <your Jenkins instance>/sonarqube-webhook/
		stage("SonarQube Quality Gate") {
			// Just in case something goes wrong, pipeline will be killed after a timeout
			timeout(time: 2, unit: 'MINUTES') {
				def qualityGate = waitForQualityGate() // Reuse taskId previously collected by withSonarQubeEnv
				if (qualityGate.status != 'OK') {
					//error "Pipeline aborted due to quality gate failure: ${qualityGate.status}"
					println("SonarQube Quality Gate Failed.failure: ${qualityGate.status}")
				} else
				{
					println("SonarQube Quality Gate Passed")
				}
			}
		}

		stage('Docker Clean'){ utils.removeImages(artifactName) }

		stage('Docker Build'){
			dir('demandplannerapi') {
				echo "Starting Docker Image Creation..."
				sh "mvn docker:build"
				echo "Docker Image Creation Complted..."
			}
		}

		//if (GIT_IMAGE_PUSH.toBoolean()) {
			sshagent (credentials: ['git-repo-ssh-access']) {
				//Save one or more images to a tar archive.
				stage('Save Docker Image'){
					utils.pushImageToRepo('demandplannerapi', distroDirPath, artifactName, releasedVersion )
				}
			}
		//}

		if (GIT_TAG.toBoolean()) {
			sshagent (credentials: ['git-repo-ssh-access']) {
				stage('Tag Branch'){
					dir('demandplannerapi') {
						utils.tagBranch(apiRepoUrl, releasedVersion)
					}
				}
			}
			sh "docker images"
		}

		//docker ps -a -q --filter=ancestor=sonarqube | xargs -I {} docker stop {}
		//docker ps -a -q --filter=ancestor=sonarqube | xargs -I {} docker rm {}

		stage('deploy to DEV'){
			utils.deployAPIToDev(artifactName, releasedVersion, PROP_ENV)
		}

		/*
			//if GIT_IMAGE_PUSH.toBoolean() is true, then only we get latest image. Hence here add if (GIT_IMAGE_PUSH.toBoolean()) true condition.
			if (GIT_IMAGE_PUSH.toBoolean()) {
				stage('Save Image to QA'){
					utils.saveImage(distroDirPath, artifactName, releasedVersion, "10.0.31.242")
					//versions = input message: 'Choose testload version!', ok: 'SET', parameters: [choice(name: 'TESTLOAD_VERSION', choices: "${version_collection}", description: '')]

					//sh 'ssh -t centos@10.0.31.242 "ls && sudo docker load -i ${artifactName}-${releasedVersion}.tar" '
				}
			}
		*/

	}catch (error) {
		println error
		// If there was an exception thrown, the build failed
		currentBuild.result = 'FAILURE'
		throw error
	} finally {
		// Success or failure, always send notifications
		utils.sendNotification(currentBuild.result)
	}
}


