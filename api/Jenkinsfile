#!/usr/bin/env groovy

node {
	properties([
		[$class: 'BuildDiscarderProperty', strategy:
			[$class: 'LogRotator', numToKeepStr: '3']],
		disableConcurrentBuilds(),
		parameters([
			choice(choices: ["master", "develop"].join("\n"), description: 'API Branch Name', name: 'API_GIT_BRANCH'),
			choice(choices: ["master", "develop"].join("\n"), description: 'Distro Branch Name', name: 'DISTRO_GIT_BRANCH'),
			choice(choices: ["dev", "qa"].join("\n"), description: 'Properties Environment', name: 'PROP_ENV'),
			booleanParam(name: 'GIT_IMAGE_PUSH', defaultValue: false,	description: 'Image store required or not'),
			booleanParam(name: 'GIT_TAG', defaultValue: false, description: 'Tagging required or not')
		]),
		pipelineTriggers(
		[upstream(threshold: hudson.model.Result.SUCCESS,upstreamProjects: "common")
			//pollSCM('H/15 * * * *'),
			//pollSCM('* * * * *'),
			//cron('@daily')
		])
	])

	try {
		// =========== USER DEFINED VARS ===========
		def workspacePath = pwd()
		echo "${workspacePath}"
		def mvnHome = tool name: "Maven_V3"
		env.PATH = "${mvnHome}/bin:${env.PATH}"
		def apiRepoUrl = 'ssh://git@innersource.accenture.com/appq/demandplannerapi.git'
		def distroRepoUrl = 'ssh://git@innersource.accenture.com/appq/distro.git'
		def devopsRepoUrl = 'ssh://git@innersource.accenture.com/appq/devops.git'
		def distroDirPath = "/tmp/jenkins/distro"
		def artifactName
		def releasedVersion
		// =========== USER DEFINED VARS ===========

		stage('Git Checkout') {
			deleteDir()
			echo "Checkout in progress..."
			dir('demandplannerapi') {
				git branch: '${API_GIT_BRANCH}',
				credentialsId: 'git-repo-ssh-access',
				url: "${apiRepoUrl}"
			}

			artifactName = getArtifact()
			releasedVersion = getReleasedVersion()

			echo "artifactName:${artifactName}"
			echo "releasedVersion:${releasedVersion}"

			dir('devops') {
				git branch: 'master',
				credentialsId: 'git-repo-ssh-access',
				url: "${devopsRepoUrl}"
			}

			// Check for directory
			if(!fileExists(distroDirPath))
			{
				sh "whoami"
				echo "${distroDirPath} doesn't exist.Continue cloning ..."

				dir(distroDirPath){
					git branch: '${DISTRO_GIT_BRANCH}',
					credentialsId: 'git-repo-ssh-access',
					url: "${distroRepoUrl}"
				}
			}
			else {
				echo "${distroDirPath} is already exist.Continue updating ..."
				sshagent (credentials: ['git-repo-ssh-access']) {
					dir(distroDirPath) { sh "git pull origin HEAD:master" }
				}
			}
		}

		stage ('Maven Build') {
			dir('demandplannerapi') { sh "mvn clean install -Dmaven.test.skip=true" }
		}

		stage ('Junit Test') { dir('demandplannerapi') {sh "mvn test" }}

		stage('SonarQube Analysis') {
			dir('demandplannerapi') {
				withSonarQubeEnv('SonarQube_V7') { // SonarQube taskId is automatically attached to the pipeline context
					sh "mvn org.sonarsource.scanner.maven:sonar-maven-plugin:3.3.0.603:sonar" }
			}
		}

		// Configure a webhook in your SonarQube server pointing to <your Jenkins instance>/sonarqube-webhook/
		stage("SonarQube Quality Gate") {
			// Just in case something goes wrong, pipeline will be killed after a timeout
			timeout(time: 2, unit: 'MINUTES') {
				def qualityGate = waitForQualityGate() // Reuse taskId previously collected by withSonarQubeEnv
				if (qualityGate.status != 'OK') {
					//error "Pipeline aborted due to quality gate failure: ${qualityGate.status}"
					println("SonarQube Quality Gate Failed.failure: ${qualityGate.status}")
				} else
				{
					println("SonarQube Quality Gate Passed")
				}
			}
		}

		stage('Docker Clean'){
			try {
				sh 'docker rmi -f $(docker images -f "dangling=true" -q)'
			} catch (err) {
				echo "Trying to remove dangling Images: ${err}"
			}

			try {
				sh 'docker rmi -f $(docker images | grep ${artifactName} | awk \"{print $3}\")'
			} catch (err) {
				echo "Trying remove ${artifactName}: ${err}"
			}
		}

		stage('Docker Build'){
			dir('demandplannerapi') {
				echo "Starting Docker Image Creation..."
				sh "mvn docker:build"
				echo "Docker Image Creation Complted..."
			}
		}

		if (GIT_IMAGE_PUSH.toBoolean()) {
			sshagent (credentials: ['git-repo-ssh-access']) {
				//Save one or more images to a tar archive.
				stage('Save Docker Image'){	
					sh "docker images"
					dir ('demandplannerapi') {
						//docker save -o <path for generated tar file> <existing image name>
						sh "docker save -o target/${artifactName}-${releasedVersion}.tar ${artifactName}:${releasedVersion}"
						echo "Copying tar file..."
						sh "cp -rf target/${artifactName}-${releasedVersion}.tar ${distroDirPath}"
					}

					dir (distroDirPath) {
						sh "git pull origin master"
						sh "git add ${artifactName}-${releasedVersion}.tar"
						sh 'git commit -m "Jenkins Job:${JOB_NAME} pushing image tar file" '
						sh "git push origin HEAD:master"
					}
				}
		   }	
		}
		
		if (GIT_TAG.toBoolean()) {
			sshagent (credentials: ['git-repo-ssh-access']) {	
				stage('Tag Branch'){
					dir('demandplannerapi') {
						sh "ls -l"
						sh "git remote set-url origin ${apiRepoUrl}"
						//sh "git tag ${IMAGE_BRANCH_PREFIX}-${BUILD_NUMBER}"
						sh "git tag ${releasedVersion}-${BUILD_NUMBER}"
						sh "git push --tags"
					}
				}
			}
			sh "docker images"
		}

		stage('deploy to DEV'){
			sh "docker ps"
			def  containerId = sh (
					script: "docker ps --no-trunc -aqf 'name=${artifactName}'",
					returnStdout: true
					).trim()
			echo "containerId: ${containerId}"

			if (containerId != "") {
				sh "docker stop ${containerId}"
				sh "docker rm -f ${containerId}"
			}
			sh "docker run -e 'SPRING_PROFILES_ACTIVE=${PROP_ENV}' -d -p 8099:8090 --name  ${artifactName} -t ${artifactName}"
		}


		// .ssh place ssh key to connect to 
		// ssh config file
		// 
		stage('Promote to QA'){
			//versions = input message: 'Choose testload version!', ok: 'SET', parameters: [choice(name: 'TESTLOAD_VERSION', choices: "${version_collection}", description: '')]
			timeout(activity: true, time: 20, unit: 'SECONDS') {
				input message: 'Deploy to QA?', ok: 'Deploy'
			}

			//def filePath = ${workspacePath}/
			//sh "ssh -i devops/artifacts/qcom-bang-key.ppk centos@ip-10-0-31-10.ec2.internal 'nohup sleep 300 >/dev/null 2>/dev/null </dev/null &'"
			//sh "ssh -i devops/artifacts/qcom-bang-key.ppk centos@ip-10-0-31-10.ec2.internal;pwd"
			dir('devops') {
				sh "ssh -i artifacts/qcom-bang-key.ppk centos@10.0.31.10"
			}
			
			//sh "scp -Cpv -i devops/artifacts/qcom-bang-key.ppk  ${distroDirPath}/${artifactName}-${releasedVersion}.tar centos@10.0.31.10:/home/centos"
			
						// by default look for private key/identity file  @/var/lib/jenkins/.ssh
			
			//dir (distroDirPath) { sh "scp  -Cpv ${artifactName}-${releasedVersion}.tar centos@10.0.31.10:/home/centos" }
			
			//privae key here and pubcli key in /home/centos/
			//ssh try to another box (from jenkins to another box) - where to place private and public key (ssh-agent other ways/sshdconfig)
			//

		}

		stage('Promote to PROD'){

		}

	}catch (Error) {
		println Error
	}
}

def getReleasedVersion() {
	def matcher = readFile('demandplannerapi/pom.xml') =~ '<version>(.+?)</version>'
	matcher ? matcher[0][1] : null
}

def getArtifact() {
	def matcher = readFile('demandplannerapi/pom.xml') =~ '<artifactId>(.+?)</artifactId>'
	matcher ? matcher[0][1] : null
}
