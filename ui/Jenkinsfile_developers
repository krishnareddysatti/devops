#!/usr/bin/env groovy
@Library('JenkinsSharedLibrary') _

// =========== GLOBAL VARS ===========
def artifactName, releasedVersion , qaServerIP, distroDirPath
// =========== GLOBAL VARS ===========

node {
	def projectProperties = [
		[$class: 'BuildDiscarderProperty',strategy: [$class: 'LogRotator', numToKeepStr: '3']],
		disableConcurrentBuilds(),
		parameters([
			string(name: 'MAJOR_VERSION', description: '', defaultValue: "0"),
			string(name: 'MINOR_VERSION', description: '', defaultValue: "SNAPSHOT"),
			string(name: 'GIT_BRANCH', description: 'UI Branch Name', defaultValue: "develop"),
			string(name: 'DEV_BOX_IP', description: '', defaultValue: "10.0.31.138"),
			string(name: 'QA_BOX_IP', description: '', defaultValue: "10.0.31.242"),
			booleanParam(name: 'GIT_IMAGE_PUSH', defaultValue: false,	description: 'Save image to a tar archive'),
			booleanParam(name: 'GIT_TAG', defaultValue: false, description: 'Tagging required or not')
		]),
	]
	//projectProperties.add(pipelineTriggers([cron('H 21 * * *')]))

	properties(projectProperties)

	Utils utils = new Utils()

	try {
		// =========== USER DEFINED VARS ===========
		def workspacePath = pwd()
		def nodeHome = tool 'NodeJS_V8'
		env.PATH="${env.PATH}:${nodeHome}/bin"
		def uiRepoUrl = 'ssh://git@innersource.accenture.com/appq/demandplannerui.git'
		def distroRepoUrl = 'ssh://git@innersource.accenture.com/appq/distro_ui.git'

		// "/product/jenkins" folder should exist and have jenkins user permissions.
		distroDirPath = "/product/jenkins/distro_ui" //"/tmp/jenkins/distro_ui"

		artifactName = 'demandplannerui'
		def applicationDir = 'demandplannerui'
		releasedVersion = "${MAJOR_VERSION}.${MINOR_VERSION}.${BUILD_NUMBER}"
		def branchName = "${GIT_BRANCH}"
		def devServerIP = "${DEV_BOX_IP}"
		qaServerIP = "${QA_BOX_IP}"
		// =========== USER DEFINED VARS ===========

		echo "workspacePath: ${workspacePath}"

		stage('Git Checkout') {
			utils.sourceCodeCheckout(applicationDir, branchName, uiRepoUrl, distroDirPath, distroRepoUrl)
		}

		stage('NPM Build') {
			//'demandplannerui_npmbuild' folder will have ng build generated 'dist' folder(To avoid putting 'dist' folder in  'demandplannerui').
			utils.npmBuild('demandplannerui_npmbuild', branchName, uiRepoUrl)
		}

		stage('SonarQube Analysis') { utils.uiCodeQualityAnalysis('demandplannerui_npmbuild') }

		stage("SonarQube Quality Gate") { utils.processQualityGate() }

		utils.removeImages(artifactName)  // To clean images created on Jenkins BOX
		
		stage('Docker Build') {
			utils.uiDockerBuild(applicationDir, artifactName, releasedVersion)
		}

		saveImage(applicationDir, distroDirPath, artifactName, releasedVersion, GIT_IMAGE_PUSH, utils)
		tagBranch(applicationDir, uiRepoUrl, releasedVersion, GIT_TAG, utils)

		// TODO: remove the tar files from server /home directory :
		// TODO: try to execute Shell Script on Server : https://medium.com/devopslinks/a-hacky-hackers-guide-to-hacking-together-jenkins-scripted-pipelines-part-3-aca73bd33eaa
		if (devServerIP != null && devServerIP != "") {
			dockerClean(artifactName, devServerIP, utils)
			loadImage(distroDirPath, artifactName, releasedVersion, devServerIP, utils)
			stage('deploy to DEV'){
				utils.stopContainer(artifactName, devServerIP)
				// TODO: update the environment field "dev". CURRENTLY PASSING EMPTY
				deployImage(artifactName, releasedVersion, "", devServerIP, utils)
			}
		} else {
			echo "Please provide dev server IP"
			throw error
		}
	}catch (error) {
		println error
		// If there was an exception thrown, the build failed
		currentBuild.result = 'FAILURE'
		throw error
	} finally {
		// Success or failure, always send notifications
		utils.sendNotification(currentBuild.result)
	}
}

stage('Deploy Approval') {
	def userInput = input(
			id: 'deployToQA', message: 'Do you wish to promote build to QA?', ok: 'ok', parameters: [string(defaultValue: 'Approved', description: '', name: 'Deploy Approval?')])
	echo ("Deploy Approval: " + userInput)
}

node {
	Utils utils = new Utils()
	try {
		def workspacePath = pwd()
		echo "workspacePath in SECOND NODE: ${workspacePath}"
		echo "artifactName: ${artifactName}"
		echo "releasedVersion: ${releasedVersion}"
		echo "qaServerIP: ${qaServerIP}"
		echo "distroDirPath: ${distroDirPath}"
		stage('deploy to QA') {
			if (qaServerIP != null && qaServerIP != "") {
				dockerClean(artifactName, qaServerIP, utils)
				loadImage(distroDirPath, artifactName, releasedVersion, qaServerIP, utils)
				utils.stopContainer(artifactName, qaServerIP)
				// TODO: update the environment field "qa". CURRENTLY PASSING EMPTY
				deployImage(artifactName, releasedVersion, "", qaServerIP, utils)
			}
		}
	} catch (error) {
		println error
		// If there was an exception thrown, the build failed
		currentBuild.result = 'FAILURE'
		throw error
	} finally {
		// Success or failure, always send notifications
		utils.sendNotification(currentBuild.result)
	}
}


def saveImage(applicationDir, distroDirPath, artifactName, releasedVersion, GIT_IMAGE_PUSH, utils) {
	stage('Save Image to Tar Archive') {
		utils.saveImage(applicationDir, distroDirPath, artifactName, releasedVersion, GIT_IMAGE_PUSH)
	}
}

def tagBranch(applicationDir, uiRepoUrl, releasedVersion,GIT_TAG, utils) {
	if (GIT_TAG.toBoolean()) {
		stage('Tag Branch') {
			utils.tagBranch(applicationDir, uiRepoUrl, releasedVersion)
		}
		sh "docker images"
	}
}

def dockerClean(artifactName, serverIP, utils) {
	//stage('Docker Clean'){
	utils.removeDanglingImages(artifactName, serverIP)
	//}
}

def loadImage(distroDirPath, artifactName, releasedVersion, destinationIP, utils) {
	//stage('load Image'){
	utils.loadImage(distroDirPath, artifactName, releasedVersion, destinationIP)
	//}
}

def deployImage(artifactName, releasedVersion, PROP_ENV, destinationIP, utils) {
	utils.promoteUIToEnv(artifactName, releasedVersion, PROP_ENV, destinationIP)
}