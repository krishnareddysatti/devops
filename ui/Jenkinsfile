#!/usr/bin/env groovy
@Library('JenkinsSharedLibrary') _

node {
	properties([
		[$class: 'BuildDiscarderProperty', strategy:
			[$class: 'LogRotator', numToKeepStr: '3']],
		disableConcurrentBuilds(),
		parameters([
			choice(choices: ["develop", "master", "feature/ngbuildfix"].join("\n"), description: 'API Branch Name', name: 'UI_GIT_BRANCH'),
			choice(choices: ["master", "develop"].join("\n"), description: 'Distro Branch Name', name: 'DISTRO_GIT_BRANCH'),
			choice(choices: ["dev", "qa"].join("\n"), description: 'Properties Environment', name: 'PROP_ENV'),
			booleanParam(name: 'GIT_IMAGE_PUSH', defaultValue: false,	description: 'Image store required or not'),
			booleanParam(name: 'GIT_TAG', defaultValue: false, description: 'Tagging required or not'),
			booleanParam(name: 'NG_BUILD', defaultValue: false,	description: 'ng build required or not')
		]),
		pipelineTriggers([
			//pollSCM('H/15 * * * *'),
			//pollSCM('* * * * *'),
			//cron('@daily')
		])
	])

	Utils utils = new Utils()

	try {
		// =========== USER DEFINED VARS ===========
		def workspacePath = pwd()
		def nodeHome = tool 'NodeJS_V8'
		env.PATH="${env.PATH}:${nodeHome}/bin"
		def uiRepoUrl = 'ssh://git@innersource.accenture.com/appq/demandplannerui.git'
		def distroRepoUrl = 'ssh://git@innersource.accenture.com/appq/distro_ui.git'
		def distroDirPath = "/tmp/jenkins/distro_ui"
		def sonarqubeScannerHome = tool 'SonarQubeScanner_V3'
		def artifactName = 'demandplannerui'
		// TODO: dynamically fetch from package.json
		def releasedVersion ='0.1'
		// =========== USER DEFINED VARS ===========

		stage('Git Checkout') {
			deleteDir()
			echo "Checkout in progress..."
			dir('demandplannerui') {
				git branch: '${UI_GIT_BRANCH}',
				credentialsId: 'git-repo-ssh-access',
				url: "${uiRepoUrl}"
			}

			// Check for directory
			if(!fileExists(distroDirPath))
			{
				echo "${distroDirPath} doesn't exist.Continue cloning ..."

				dir(distroDirPath){
					git branch: '${DISTRO_GIT_BRANCH}',
					credentialsId: 'git-repo-ssh-access',
					url: "${distroRepoUrl}"
				}
			}
			else {
				echo "${distroDirPath} is already exist.Continue updating ..."
				sshagent (credentials: ['git-repo-ssh-access']) {
					dir(distroDirPath) { sh "git pull origin HEAD:master" }
				}
			}
		}

		//This stage installs all of the node dependencies, performs linting and builds the code.
		stage('NPM Build') {
			// TODO: //ng lint Update her about ng lint
			dir('demandplannerui') { sh '''
						node --version
						npm --version
						npm install -g npm@5.6.0 @angular/cli@~1.7.3
						npm install
						ng build --prod --aot
				'''   }
		}

		// TODO: skipping testing as of now
		// TODO: npm test make necessary changes.Launching browser ChromeHeadless
		/*
		 stage ('NPM Test') {
		 dir('demandplannerui') {
		 try {sh 'npm test' }catch (err) {
		 echo " NPM Test Stage Caught: ${err}"
		 }}
		 }*/

		/* TODO: parameterize project version
		 * " -Dsonar.projectKey=demo:demandplannerui"+
		 * " -Dsonar.projectName=demandplannerui" +
		 * " -Dsonar.projectVersion=V1" +
		 *
		 * add below line after "to include test"
		 *
		 */
		// " -Dsonar.test.inclusions=**/*.spec.ts" +

		stage('SonarQube Analysis') {
			dir('demandplannerui') {
				withSonarQubeEnv('SonarQube_V7') {
					sh 'ls -l'
					sh "${sonarqubeScannerHome}/bin/sonar-scanner"+
							" -Dsonar.projectKey=demandplannerui"+
							" -Dsonar.sources=src" +
							" -Dsonar.exclusions=**/node_modules/**,**/*.spec.ts" +
							" -Dsonar.tests=src" +
							" -Dsonar.test.inclusions=**/*.spec.ts"
					" -Dsonar.ts.tslintconfigpath=tslint.json" +
							" -Dsonar.ts.lcov.reportpath=test-results/coverage/coverage.lcov" +
							" -Dsonar.sourceEncoding=UTF-8"
				}
			}
		}

		// Configure a webhook in your SonarQube server pointing to <your Jenkins instance>/sonarqube-webhook/
		stage("SonarQube Quality Gate") {
			// Just in case something goes wrong, pipeline will be killed after a timeout
			timeout(time: 2, unit: 'MINUTES') {
				def qualityGate = waitForQualityGate() // Reuse taskId previously collected by withSonarQubeEnv
				if (qualityGate.status != 'OK') {
					//error "Pipeline aborted due to quality gate failure: ${qualityGate.status}"
					println("SonarQube Quality Gate Failed.failure: ${qualityGate.status}")
				} else
				{
					println("SonarQube Quality Gate Passed")
				}
			}
		}

		stage('Docker Clean'){ utils.removeImages(artifactName) }

		stage('Docker Build'){
			dir('demandplannerui') {
				echo "Starting Docker Image Creation..."
				sh "docker build -t ${artifactName}:${releasedVersion} ."
				echo "Docker Image Creation Complted..."
			}
		}

		if (GIT_IMAGE_PUSH.toBoolean()) {
			sshagent (credentials: ['git-repo-ssh-access']) {
				//Save one or more images to a tar archive.
				stage('Save Docker Image') {
					utils.pushImageToRepo('demandplannerui', distroDirPath, artifactName, releasedVersion )
				}
			}
		}

		if (GIT_TAG.toBoolean()) {
			sshagent (credentials: ['git-repo-ssh-access']) {
				stage('Tag Branch'){
					dir('demandplannerui') {
						utils.tagBranch(uiRepoUrl, releasedVersion)
					}
				}
			}
			sh "docker images"
		}

		//docker ps -a -q --filter=ancestor=sonarqube | xargs -I {} docker stop {}
		//docker ps -a -q --filter=ancestor=sonarqube | xargs -I {} docker rm {}

		//TODO: has to define PROP_ENV
		stage('deploy to DEV'){
			utils.deployUIToDev(artifactName, releasedVersion, PROP_ENV)
		}

		// if GIT_IMAGE_PUSH.toBoolean() is true, then only we get latest image. Hence here add if (GIT_IMAGE_PUSH.toBoolean()) true condition.
		if (GIT_IMAGE_PUSH.toBoolean()) {
			utils.saveImage(distroDirPath, artifactName, releasedVersion, "10.0.31.242")
		}
	}catch (error) {
		println error
		// If there was an exception thrown, the build failed
		currentBuild.result = 'FAILURE'
		throw error
	} finally {
		// Success or failure, always send notifications
		utils.sendNotification(currentBuild.result)
	}
}
